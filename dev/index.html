<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TJLF · TJLF</title><meta name="title" content="TJLF · TJLF"/><meta property="og:title" content="TJLF · TJLF"/><meta property="twitter:title" content="TJLF · TJLF"/><meta name="description" content="Documentation for TJLF."/><meta property="og:description" content="Documentation for TJLF."/><meta property="twitter:description" content="Documentation for TJLF."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-65D8V8C8VQ"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-65D8V8C8VQ', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TJLF</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>TJLF</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#How-to-Run"><span>How to Run</span></a></li><li class="toplevel"><a class="tocitem" href="#InputTJLF"><span>InputTJLF</span></a></li><li><a class="tocitem" href="#New-Parameters"><span>New Parameters</span></a></li><li><a class="tocitem" href="#Deleted-Parameters"><span>Deleted Parameters</span></a></li><li class="toplevel"><a class="tocitem" href="#Eigenvalue-Solver"><span>Eigenvalue Solver</span></a></li><li class="toplevel"><a class="tocitem" href="#Arpack.jl"><span>Arpack.jl</span></a></li><li class="toplevel"><a class="tocitem" href="#Indices-of-Arrays"><span>Indices of Arrays</span></a></li><li class="toplevel"><a class="tocitem" href="#Multithreading"><span>Multithreading</span></a></li><li class="toplevel"><a class="tocitem" href="#Bash-Folder"><span>Bash Folder</span></a></li><li class="toplevel"><a class="tocitem" href="#Other-Notes-from-DSUN"><span>Other Notes from DSUN</span></a></li><li><a class="tocitem" href="#Online-documentation"><span>Online documentation</span></a></li><li><a class="tocitem" href="#Citation"><span>Citation</span></a></li></ul></li><li><a class="tocitem" href="api/">API Reference</a></li><li><a class="tocitem" href="license/">License</a></li><li><a class="tocitem" href="notice/">Notice</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TJLF</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TJLF</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ProjectTorreyPines/TJLF.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ProjectTorreyPines/TJLF.jl/blob/master/README.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TJLF"><a class="docs-heading-anchor" href="#TJLF">TJLF</a><a id="TJLF-1"></a><a class="docs-heading-anchor-permalink" href="#TJLF" title="Permalink"></a></h1><p>Tglf in Julia Learned from Fortran (TJLF)</p><h1 id="How-to-Run"><a class="docs-heading-anchor" href="#How-to-Run">How to Run</a><a id="How-to-Run-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Run" title="Permalink"></a></h1><p>First you must create a InputTJLF struct or Vector of InputTJLF structs. The best way to do this is to call readInput(directory) where directory points at an input.tglf (not .gen) file. Then, you can call either run(InputTJLF) or run<em>tjlf(InputTJLF)/run</em>tjlf(Vector{InputTJLF}).</p><p>run() will return you QL<em>weights, eigenvalue, QL</em>flux<em>out, flux</em>spectrum</p><p>run_tjlf() will return you the summed fluxes aka the array of actual values you care about with like flux matching&lt;br&gt; (see <a href="#indices-of-arrays">Indices of Arrays</a> for how these arrays are structured)</p><p>Internal to these run() calls, there is a beginning, middle, end like I referred to in my presentation:&lt;br&gt; Beginning:  &lt;pre&gt;outputHermite = gauss<em>hermite(inputTJLF) satParams = get</em>sat<em>params(inputTJLF) inputTJLF.KY</em>SPECTRUM .= get<em>ky</em>spectrum(inputTJLF, satParams.grad<em>r0)&lt;/pre&gt;&lt;br&gt; Middle: &lt;pre&gt;QL</em>weights, eigenvalue = tjlf<em>TM(inputTJLF, satParams, outputHermite)&lt;/pre&gt;&lt;br&gt; End: &lt;pre&gt;QL</em>flux<em>out, flux</em>spectrum = sum<em>ky</em>spectrum(inputTJLF, satParams, eigenvalue[:,:,1], QL_weights)&lt;/pre&gt;</p><h1 id="InputTJLF"><a class="docs-heading-anchor" href="#InputTJLF">InputTJLF</a><a id="InputTJLF-1"></a><a class="docs-heading-anchor-permalink" href="#InputTJLF" title="Permalink"></a></h1><p>The InputTJLF struct can be populated with an InputTGLF struct, the translation is done in the tjlf_modules.jl file, but there are parameters missing between the two (see <a href="#deleted-parameters">Deleted Parameters</a>). The structure can also be populated with a input.tglf file (not .gen) if you pass the file directory to the readInput() function. </p><p>Currently, InputTJLF structs do <strong>NOT</strong> have any default values (maybe like one or two exceptions) and should throw an error if it is not properly populated, this is to ensure the user is fully aware of the parameters they are using.</p><h2 id="New-Parameters"><a class="docs-heading-anchor" href="#New-Parameters">New Parameters</a><a id="New-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#New-Parameters" title="Permalink"></a></h2><p>InputTJLF mostly follows the input.tglf file variables, but there are a couple new things</p><p>FIND<em>WIDTH::Bool - this is in the input.tglf file, but is used different than in the Fortran, I have repurposed this variable to be a flag to tell the code whether or not we are providing an external width spectrum to avoid extra calls to tjlf</em>max.jl that solves for width (see <a href="#eigenvalue-solver">Eigenvalue Solver</a>)</p><p>WIDTH<em>SPECTRUM::Vector - external width spectrum used if FIND</em>WIDTH is False. If FIND<em>WIDTH is True, this Vector will be populated with widths for each ky grid point. The idea is that you can run with FIND</em>WIDTH set as True, it will automatically save the width spectrum, you can then change the gradients of that particular struct, and then change the FIND_WIDTH flag to False. Or, you can easily save this value to other InputTJLF struct, not sure why you would necessarily, but the information is here.</p><p>FIND<em>EIGEN::Bool - this flag tells the code which solver to use when solving for the eigenvalues, if unsure, FIND</em>EIGEN as True is more robust (see <a href="#eigenvalue-solver">Eigenvalue Solver</a>). Should ONLY be False if FIND<em>EIGEN is also False because it would be suspicious if you are confident on the eigenvalues enough to use and not confident on the width values (it would also probably break tjlf</em>max.jl), there should be an assertion to check this.</p><p>EIGEN<em>SPECTRUM::Vector - external eigen spectrum used on the first pass if FIND</em>EIGEN is False. This value is set to the sigma parameter of the eigs() solver and acts as an initial guess for the iterative solver. Currently, this is a vector that automatically stores the most unstable eigenvalues from the first pass, but it might be smart to save the eigenvalues for each mode and rework how eigs works in LS.jl</p><p>SMALL::Float - value used to rewrite the eigenvalue problem as a system of linear equations like the Fortran does (default 1e-13)</p><h2 id="Deleted-Parameters"><a class="docs-heading-anchor" href="#Deleted-Parameters">Deleted Parameters</a><a id="Deleted-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Deleted-Parameters" title="Permalink"></a></h2><p>I deleted the parameters in the InputTJLF struct that are old and not used. I left comments and deleted them in commit <a href="https://github.com/ProjectTorreyPines/TJLF.jl/commit/b9a9c99b40a3ba5fcbc683eb94df4ec8b6fd5671">b9a9c99</a> and commit <a href="https://github.com/ProjectTorreyPines/TJLF.jl/commit/18f810fdf277a691b584f987781b976cccdcbb5b">18f810f</a>.</p><p>Deleted parameters: USE<em>TRANSPORT</em>MODEL,GEOMETRY<em>FLAG,B</em>MODEL<em>SA,FT</em>MODEL<em>SA,VPAR</em>SHEAR<em>MODEL,WRITE</em>WAVEFUNCTION<em>FLAG,VTS</em>SHEAR,VNS<em>SHEAR,VEXB,RMIN</em>SA,RMAJ<em>SA,Q</em>SA,SHAT<em>SA,ALPHA</em>SA,XWELL<em>SA,THETA0</em>SA,NN<em>MAX</em>ERROR</p><h1 id="Eigenvalue-Solver"><a class="docs-heading-anchor" href="#Eigenvalue-Solver">Eigenvalue Solver</a><a id="Eigenvalue-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Solver" title="Permalink"></a></h1><p>Currently, Arpack.jl&#39;s eigs(), can be used in tjlf<em>LINEAR</em>SOLUTION.jl and tjlf<em>eigensolver.jl as a fast iterative solver. In tjlf</em>LS.jl, eigs() is used to solve for the eigenvector instead of rewriting the generalized eigenvalue problem as a system of linear equations like TGLF, which is potentially a little troublesome. It is also used in tjlf<em>eigensolver.jl if you provide a EIGEN</em>SPECTRUM and set FIND_EIGEN to False. eigs() does a shift and inverse iteration to solve the generalized eigenvalue problem, specifying sigma gives the shift, by setting which=:LM you tell eigs() to compute eigenvalues around sigma. I have tried which=:LR (LM is largest magnitude and LR is largest real part), but sometimes the solver will find &quot;fake&quot; eigenvalues with very large real and imaginary parts. I have found using :LM and setting sigma as the most unstable mode has worked, but more testing would be good.</p><p>Table of the three different combinations of the solvers used in TJLF</p><pre><code class="nohighlight hljs">+--------------+-----------------------------------------------+
|              |                      FirstPass()              |
+--------------+---------+-----------------+-------------------+
|              |         | ggev!()         | eigs()            |
|              +---------+-----------------+-------------------+
|              | ggev!() |      1.141s     | 522.710 ms        |
|              | eigs()  |     robust,     | robust?           |
|              |         | most &quot;correct&quot;, | thread scales??   |
| SecondPass() |         |  thread scales? | best for 1 thread |
| (eigenvalue, +---------+-----------------+-------------------+
| eigenvector) | ggev!() |      1.091s     |                   |
|              | gsev!() |       TGLF      |                   |
|              |         |     robust,     |                   |
|              |         |  thread scales! |                   |
+--------------+---------+-----------------+-------------------+</code></pre><p>To run top left, set the InputTJLF SMALL parameter = 0.0, set FIND<em>EIGEN = False&lt;br&gt; To run mid left, use the default InputTJLF SMALL parameter = 1e-13&lt;br&gt; To run top right, set the InputTJLF SMALL parameter = 0.0, set FIND</em>EIGEN = True&lt;br&gt;</p><h1 id="Arpack.jl"><a class="docs-heading-anchor" href="#Arpack.jl">Arpack.jl</a><a id="Arpack.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Arpack.jl" title="Permalink"></a></h1><p>NOTE, If you are getting:&lt;br&gt; &lt;pre&gt; Error: XYAUPD_Exception: Maximum number of iterations taken. All possible eigenvalues of OP has been found.&lt;br&gt; │ IPARAM(5) returns the number of wanted converged Ritz values.&lt;br&gt; │   info = 1&lt;/pre&gt;</p><p>Make sure you are using Arpack v0.5.3 and NOT v0.5.4, the current version does not work. You might have to restart your Julia enviroment, activate TJLF, and <strong>build</strong>.</p><p>Also, Arpack.jl&#39;s eigs() is <strong>NOT</strong> thread safe. I have locks in the code to keep things safe. In the future, GenericArpack.jl should provide a pure Julia version of the Arpack algorithm that is thread safe, but it is still under development and seems to be a ways off.</p><h1 id="Indices-of-Arrays"><a class="docs-heading-anchor" href="#Indices-of-Arrays">Indices of Arrays</a><a id="Indices-of-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Indices-of-Arrays" title="Permalink"></a></h1><p>There are some 3D and 5D arrays where the indices are not obvious. They are specified in the function comments where they appear, but I will repeat them here:&lt;br&gt; &lt;pre&gt;QL<em>weights::Array{5} - [field, species, mode, ky, type]&lt;br&gt;     type: (particle, energy, torodial stress, parallel stress, exchange)&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;flux</em>spectrum::Array{5} - [field, species, mode, ky, type]&lt;br&gt;     type: (particle, energy, torodial stress, parallel stress, exchange)&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;eigenvalue::Array{3} - [mode, ky, type]&lt;br&gt;     type: (gamma, frequency)&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;QL<em>flux</em>out::Array{3} - [field, species, type]&lt;br&gt;     type: (particle, energy, torodial stress, parallel stress, exchange)&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;&quot;Output of run_tjlf()&quot;::Array{2} - [species, type]&lt;br&gt;     type: (particle, energy, torodial stress, parallel stress, exchange)&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;species: 1 = electron, 2+ = ions&lt;/pre&gt;&lt;br&gt; &lt;pre&gt;modes: 1 = most unstable&lt;/pre&gt; The order of the indices try to take advantage of Julia&#39;s column major memory usage</p><h1 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h1><p>If you are multithreading, make sure BLAS.set<em>num</em>threads(1) is set at some point.</p><h1 id="Bash-Folder"><a class="docs-heading-anchor" href="#Bash-Folder">Bash Folder</a><a id="Bash-Folder-1"></a><a class="docs-heading-anchor-permalink" href="#Bash-Folder" title="Permalink"></a></h1><p>Wrote a Bash script for testing how number of threads affects speed. Currently it is testing on the seven radial points Tim gave me found in outputs/TIM_test/. You call the executable followed by command line arguements. If you give one number, it gives you the @btime with that number of threads. If you give two numbers, it gives you the @btime looping through those two numbers. If you give three or more numbers, it gives you the @btime for each number in the arguments. I currently don&#39;t have any implementation to test the threading speed on other test cases, but you can pretty easily copy my Julia script to meet whatever you need.</p><h1 id="Other-Notes-from-DSUN"><a class="docs-heading-anchor" href="#Other-Notes-from-DSUN">Other Notes from DSUN</a><a id="Other-Notes-from-DSUN-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Notes-from-DSUN" title="Permalink"></a></h1><p>For SAT0, TM() does not return the value of QL<em>weights (aka &quot;QL</em>flux<em>spectrum</em>out&quot; in TGLF) and instead returns the value of what TGLF refers to as flux<em>spectrum</em>out. This is because the saturation rule calculation is done in a different place (LS.jl instead of multiscale<em>spectrum.jl), and otherwise, I would have to pass this extra Array through multiple functions just for SAT0 which is tedious and ugly. Plus SAT0 isn&#39;t really used apparently. So, if you are trying to compare the QL</em>weights for a SAT0 run, make sure you keep this in mind.</p><p>The name of the SaturationParameters struct is probably not a great struct name since it doesn&#39;t really relate to the saturation rules at all and instead are more related to the Miller Geometry, not sure what a better name would be since OutputGeometry is already used.</p><p>Currently, InputTJLF&#39;s IFLUX parameter tells the code whether it is going to calculate eigenvectors. This is bad and I should probably change it into a local variable instead of a struct parameter. Ran into an issue multithreading with onePass() since it changes IFLUX in the middle of its function. The code is currently fixed with an extra &quot;find_eigenvector&quot; variable, but this should just be the standard IMO. I will try and implement this before I leave and delete the IFLUX parameter, but if this is still in the README I have not done it yet.</p><h2 id="Online-documentation"><a class="docs-heading-anchor" href="#Online-documentation">Online documentation</a><a id="Online-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Online-documentation" title="Permalink"></a></h2><p>For more details, see the <a href="https://projecttorreypines.github.io/TJLF.jl/dev">online documentation</a>.</p><p><img src="https://github.com/ProjectTorreyPines/TJLF.jl/actions/workflows/make_docs.yml/badge.svg" alt="Docs"/></p><h2 id="Citation"><a class="docs-heading-anchor" href="#Citation">Citation</a><a id="Citation-1"></a><a class="docs-heading-anchor-permalink" href="#Citation" title="Permalink"></a></h2><p>If this software contributes to an academic publication, please cite it as follows:</p><blockquote><p>T.F. Neiser, D. Sun, B. Agnew, T. Slendebroek, O. Meneghini, B.C. Lyons, A. Ghiozzi, J. McClenaghan, G. Staebler and J. Candy, <em>TJLF: The quasi-linear model of gyrokinetic transport TGLF translated to Julia</em>, APS Meeting Abstracts (2024)</p></blockquote></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 00:51">Friday 25 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
